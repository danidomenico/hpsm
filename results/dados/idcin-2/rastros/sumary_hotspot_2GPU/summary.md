<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li>
<ul>
<li><a href="#sec-1-0-1">1.0.1. How to compile</a></li>
<li><a href="#sec-1-0-2">1.0.2. Software dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">2. Gantt Charts of the whole Trace</a></li>
<li><a href="#sec-3">3. Table Summary</a></li>
<li><a href="#sec-4">4. State Duration during the Execution Time</a></li>
<li><a href="#sec-5">5. Distribution Histograms</a></li>
</ul>
</div>
</div>










# Introduction

This document presents a basic analysis of multiple StarPU
traces. First, paje *traces* will be transferred into *.csv* files and
then we analyze them with **R**. This summary is a first step that
should help researchers verify their hypothesis or find problematic
areas that require more exhaustive investigation.

Be cautious, as the following results are only a brief analysis of
the traces and many important phenomena could still be hidden. Also,
be very careful when comparing different states or traces. Even
though some large discrepancies can be irrelevant, in other cases
even the smallest differences can be essential in understanding what
exactly happened during the StarPU execution.

### How to compile

    ./starpu_summary.sh example.native.trace example.simgrid.trace

### Software dependencies

In order to run this analysis you need to have R installed:

    sudo apt-get install r-base 

Easiest way to transform *paje* traces generated by StarPU to *.csv* is to use *pjdump* program (<https://github.com/schnorr/pajeng>), so we encourage users to install it.

When R is installed, one will need to start R (e.g., from terminal) and install *knitr* package:

    R> install.packages("knitr")

Additional R packages used in this analysis (*ggplot2, plyr, data.table, RColorBrewer*) will be installed automatically when the document is compiled for the first time. If there is any trouble, install them by hand directly from R (the same way as *knitr*)

# Gantt Charts of the whole Trace

First, we show a simple gantt chart of every trace. X-axis is a
simple timeline of the execution, *Resources* on y-axis correspond
to different CPUs/GPUs that were used and finally different colors
represent different *States* of the application.

This kind of figures can often point to the idle time or
synchronization problems. Small disadvantage is that in most cases
there are too many states, thus it is impossible to display them all
on a single plot without aggregation. Therefore for any strange
behavior at a certain part of the trace, we strongly suggest to zoom
on the interval it occurred.

![plot of chunk Gantt1](figure/Gantt1-1.png)

Second, we will concentrate only on computation kernel states, to
get rid of visualization artifacts that can be introduced by other
(sometimes irrelevant) states. Normally, this plot should not be too
different from the previous one.

![plot of chunk Gantt2](figure/Gantt2-1.png)

# Table Summary

Here we present how much time application spent in each state
(OverallDuration), how many times it was in that state (Count),
mean and median values of duration (Mean and Median), and finally
what is a standard deviation (StandDev).

General information provided by this table can sometimes give an
idea to application experts which parts of code are not working as
desired. Be aware that this kind of tables hide many important
things, such as outliers, multiple modes, etc.


```
##                Value                       Origin OverallDuration Count         Mean       Median     StandDev
## 1      11funcHotspot hotspot_2GPU_26CPU.trace.csv    1.388292e+05  1280 1.084603e+02    9.8967800 1.953415e+02
## 2      11funcHotspot hotspot_2GPU_25CPU.trace.csv    1.350231e+05  1280 1.054868e+02    9.8972145 1.941274e+02
## 3               Idle hotspot_2GPU_26CPU.trace.csv    8.700273e+03  1308 6.651585e+00    0.0137820 7.097159e+01
## 4               Idle hotspot_2GPU_25CPU.trace.csv    5.654835e+03  1307 4.326576e+00    0.0138970 4.359076e+01
## 5    Submitting task hotspot_2GPU_26CPU.trace.csv    1.371566e+03  7120 1.926357e-01    0.0020730 6.638947e+00
## 6    Submitting task hotspot_2GPU_25CPU.trace.csv    1.352388e+03  7120 1.899422e-01    0.0017570 5.463758e+00
## 7  Waiting all tasks hotspot_2GPU_26CPU.trace.csv    5.927523e+03     5 1.185505e+03 1152.6953530 7.430327e+01
## 8  Waiting all tasks hotspot_2GPU_25CPU.trace.csv    5.688475e+03     5 1.137695e+03 1085.7581050 1.206704e+02
## 9       Waiting task hotspot_2GPU_26CPU.trace.csv    6.023000e-03    15 4.015333e-04    0.0003830 7.449436e-05
## 10      Waiting task hotspot_2GPU_25CPU.trace.csv    5.959000e-03    15 3.972667e-04    0.0003800 7.325832e-05
## 11      Initializing hotspot_2GPU_26CPU.trace.csv    2.835495e+02    28 1.012677e+01    0.0142970 5.217919e+01
## 12      Initializing hotspot_2GPU_25CPU.trace.csv    2.834014e+02    27 1.049635e+01    0.0143050 5.322406e+01
## 13    Deinitializing hotspot_2GPU_26CPU.trace.csv    2.098615e+01    28 7.495053e-01    0.0457690 2.589660e+00
## 14    Deinitializing hotspot_2GPU_25CPU.trace.csv    1.930410e+01    27 7.149669e-01    0.0242950 2.498069e+00
## 15          Overhead hotspot_2GPU_26CPU.trace.csv    5.394642e+02  4888 1.103650e-01    0.0036315 7.955648e-01
## 16          Overhead hotspot_2GPU_25CPU.trace.csv    5.436760e+02  4897 1.110223e-01    0.0035890 7.876120e-01
## 17           Nothing hotspot_2GPU_26CPU.trace.csv    2.233392e+04  3388 6.592066e+00    0.0015965 9.261345e+01
## 18           Nothing hotspot_2GPU_25CPU.trace.csv    1.819211e+04  3330 5.463095e+00    0.0017055 7.921022e+01
## 19          Sleeping hotspot_2GPU_26CPU.trace.csv    1.219004e+05   168 7.255979e+02  712.7511820 4.171096e+02
## 20          Sleeping hotspot_2GPU_25CPU.trace.csv    7.623295e+04   162 4.705738e+02  530.5315535 3.055454e+02
## 21           Freeing hotspot_2GPU_26CPU.trace.csv    1.829787e+01   446 4.102661e-02    0.0007230 1.099939e-01
## 22           Freeing hotspot_2GPU_25CPU.trace.csv    1.769001e+01   420 4.211907e-02    0.0007185 1.121359e-01
## 23        Allocating hotspot_2GPU_26CPU.trace.csv    1.478565e+02   446 3.315168e-01    0.0017295 5.446832e+00
## 24        Allocating hotspot_2GPU_25CPU.trace.csv    1.565828e+02   420 3.728161e-01    0.0015810 5.669347e+00
## 25     FetchingInput hotspot_2GPU_26CPU.trace.csv    1.102571e+03  1280 8.613836e-01    0.0025635 1.246596e+01
## 26     FetchingInput hotspot_2GPU_25CPU.trace.csv    1.966307e+03  1280 1.536177e+00    0.0026170 1.973545e+01
## 27     PushingOutput hotspot_2GPU_26CPU.trace.csv    1.739398e+00  1280 1.358905e-03    0.0011940 4.381131e-04
## 28     PushingOutput hotspot_2GPU_25CPU.trace.csv    1.696765e+00  1280 1.325598e-03    0.0011575 4.496095e-04
## 29   AllocatingReuse hotspot_2GPU_26CPU.trace.csv    6.489144e+02  2050 3.165436e-01    0.0011365 7.120518e+00
## 30   AllocatingReuse hotspot_2GPU_25CPU.trace.csv    3.458811e+02  2070 1.670923e-01    0.0012620 5.197906e+00
## 31        DriverCopy hotspot_2GPU_26CPU.trace.csv    1.024428e+03  4100 2.498606e-01    0.0022605 1.548183e+00
## 32        DriverCopy hotspot_2GPU_25CPU.trace.csv    1.008016e+03  4140 2.434821e-01    0.0023650 1.545501e+00
## 33   DriverCopyAsync hotspot_2GPU_26CPU.trace.csv    2.609864e+03  2050 1.273104e+00    0.5141455 1.067858e+01
## 34   DriverCopyAsync hotspot_2GPU_25CPU.trace.csv    2.668395e+03  2070 1.289080e+00    0.5478465 1.070646e+01
## 35        Scheduling hotspot_2GPU_26CPU.trace.csv    3.482343e+00  3868 9.002955e-04    0.0005850 6.995073e-04
## 36        Scheduling hotspot_2GPU_25CPU.trace.csv    3.584285e+00  3867 9.268904e-04    0.0006040 7.212846e-04
## 37         Executing hotspot_2GPU_26CPU.trace.csv    1.007496e+04  1020 9.877411e+00    9.8777270 8.122263e-02
## 38         Executing hotspot_2GPU_25CPU.trace.csv    1.021175e+04  1030 9.914323e+00    9.8839350 2.074789e-01
```

# State Duration during the Execution Time

Now, we show how duration of each state was changing during the
execution. This can display a general behavior of a state; show if
there are outliers or multiple modes; are some events occurring in
groups, etc. . It can also suggest a strange behavior of a state
during a certain time interval, which should be later investigated
more carefully.

  However, since each event is represented by a single point (and
there is no "alpha" factor), those events that happen almost
simultaneously are overplotted. Therefore density of events along
execution time may not be easy to read.

![plot of chunk Dur](figure/Dur-1.png)

# Distribution Histograms

Finally, we show a distribution of *Duration* for each state in form
of histograms. X-axis is partitioned into bins with equidistant time
intervals in milliseconds, while y-axis represents the number of
occurrences inside such intervals for a certain state. Note that for
the first plot y-axis is not fixed, meaning that the scale changes
from one row to another. This plot allows to not only to see what
was the most frequent duration of a state, but also to compare
duration between different states.

![plot of chunk Hist1](figure/Hist1-1.png)

Similar to the previous figure, only now traces are showed vertically
instead of horizontally. Note that for this plot x-axis is not fixed,
meaning that the scale changes from one column to another. This plot
allows to compare frequency of different states and in case of
multiple traces to easily compare duration distribution for each
state.

![plot of chunk Hist2](figure/Hist2-1.png)
